\section{Program architecture and Data Structures}
\label{sec:program_structure}

In this section, we will discuss the program structure and data structure used in our project. The program structure refers to the organization and arrangement of the code, while the data structure refers to the way data is stored and manipulated within the program.

\subsection{File Organization}
\label{subsec:file_organization}

In our project, we follow a structured approach to organize our files. 
We have divided our code into multiple files based on their functionality and purpose. 
This modular approach helps in better code management and improves code reusability.

\subsubsection{Entry Point of the Application}

The main file of our project is the \texttt{App.py} file, which serves as the entry point for our application. 
It creates an instance of \texttt{Pathway\_selector} \texttt{Pathway\_selector(tk.Tk)} from \texttt{views/pathway\_selector.py} and calls its \texttt{mainloop()} method to start the application.

\subsubsection{Views}

The \texttt{views} folder contains all the files related to the user interface of our application.
It contains the following files:

\begin{description}
    \item[\texttt{pathway\_selector.py}] This file contains the code for the pathway selector window, which is the first window that appears when the application is launched and serves as the application's home screen. It allows the user to select a pathway from the list of available pathways and click on the \texttt{Select} button to proceed to the next window, among other things.
    \item[\texttt{pathway\_view.py}] This file contains the code for the pathway view window. This window allows the user to solve a pathway problem using the selected pathway. It also allows the user to view a representation of the pathway and its reactions hence the name pathway view.
    \item[\texttt{benchmark\_view.py}] This file contains the code for the benchmark view window. This window allows the user to benchmark the performance of our AMPL models and compare the performance of various solvers.
\end{description}

\subsubsection{Models}

The \texttt{models} folder contains all the files related to the AMPL models used in our project.

\begin{description}
    \item[\texttt{model\_A.mod}] As described in Section \ref{sec:model_a_b}. This model is used both in the benchmarking process and when solving a pathway in the pathway\_view when the user doesn't select the \texttt{Extra restrictions} option.
    \item[\texttt{model\_B.mod}] As described in Section \ref{sec:model_a_b}. This model is only used during the benchmarking process.
    \item[\texttt{serret\_dual\_imply\_extra\_restrictions.mod}] As described in Section \ref{sec:model_dualimply_extra_restrictions}. This model is use when solving a pathway in the pathway\_view when the user selects the \texttt{Extra restrictions} option.
    \item[\texttt{serret\_dual\_imply.mod}] A varient of the model described in Section \ref{sec:model_dualimply_extra_restrictions} without the extra restrictions. This model is only used during the benchmarking process.
    \item[\texttt{serret\_old.mod}] This is the first prototype of our model as seen in Section \ref{sec:first_prototype}.
    \item[\texttt{serret\_uni\_imply.mod}] As described in Section \ref{sec:benchmark}. This model is only used during the benchmarking process.
\end{description}

\subsubsection{Utils}

The \texttt{utils} folder contains all the files related to the utility functions used in our project.

\begin{description}
    \item[ui\_utils.py] This file contains utility functions related to the user interface of our application. Namely the \texttt{pad} function which is used to add padding to the user interface and the \texttt{GridUtils} class which is used to simplify the process of adding widgets to the user interface when using the grid geometry manager from Tkinter.
    \item[KEGGIntegration.py] This file contains a singleton class, \texttt{KEGGIntegration}, that handles all the communication to the KEGG API as well as storing the results locally to avoid making additional calls upon relaunching. The class provides methods to retrieve data from the KEGG database and also has the ability to recover the stored data.
\end{description}

\subsubsection{Dynamically Generated Files}

Several files are generated dynamically by our application. These files are stored in the following directories:

\begin{description}
    \item[\texttt{dats/}] This directory contains the files all the '.dat' files generated by our application. These files are used as input to the AMPL models.
    \item[\texttt{persitent\_data/}] This directory contains the data retrieved from the KEGG API. A single file inhabits this directory, \texttt{data.json}, which, when created by our application, contains all the data retrieved from the KEGG API. This file is used to avoid making additional calls to the KEGG API upon relaunching our application.
    \item[\texttt{output/}] This directory is the default output directory when a user chooses to save the output of a pathway problem. It also contains the output of the benchmarking process.
\end{description}

\subsection{Classes and Data Structures} \label{sec:classes_data_structures}

In this section, we will discuss the classes and data structures used in our project.

\subsubsection{KEGGIntegration}

The \texttt{KEGGIntegration} class serves as a central hub for interacting with the KEGG API and managing locally stored results to enhance efficiency. It follows the singleton pattern, ensuring only one instance of the class exists at a time. This is advantageous as a single instance effectively handles all communication with the KEGG API.

During initialization, the class checks for existing data in the \texttt{data.json} file within the \texttt{persistent\_data} directory. If the file is absent, the class initiates the retrieval of data from the KEGG API, subsequently storing it in the data.json file for future reference. This approach optimizes performance by avoiding redundant API calls upon subsequent launches.

\textbf{Attributes:}

\begin{itemize}
    \item \textbf{data\_loc}: A string variable that represents the location of the data.json file. It's value is not edited throughout the execution of the program. (Data Structure: String)
    \item \textbf{map\_reaction\_id\_to\_substrates\_products\_ids}: A dictionary that maps reaction IDs to lists of substrate and product compound IDs. (Data Structure: Dictionary)
    \item \textbf{map\_synonym\_to\_compound\_id}: A dictionary that maps compound synonyms to compound IDs. (Data Structure: Dictionary)
    \item \textbf{broken\_reaction\_ids}: A list that stores the IDs of broken reactions. (Data Structure: List)
    \item \textbf{fetched\_breaking\_reaction\_ids}: A list that stores the IDs of fetched breaking reactions. (Data Structure: List)
    \item \textbf{map\_reaction\_id\_to\_list\_compound\_id}: A dictionary that maps reaction IDs to lists of compound IDs. (Data Structure: Dictionary)
    \item \textbf{map\_pathway\_id\_to\_list\_reaction\_id}: A dictionary that maps pathway IDs to lists of reaction IDs. (Data Structure: Dictionary)
    \item \textbf{map\_pathway\_id\_to\_description}: A dictionary that maps pathway IDs to pathway descriptions. (Data Structure: Dictionary)
\end{itemize}

The \texttt{KEGGIntegration} class has the following methods:

\textbf{Private methods:}

\begin{itemize}
    \item \textbf{\_\_new\_\_(cls)}: This is a special method that is automatically called when creating a new instance of the class. It ensures that only one instance of the class can be created.
    \item \textbf{\_\_get\_remaining\_breaking\_reaction\_ids(self)}: This method retrieves the remaining breaking reaction IDs that have not been fetched yet.
    \item \textbf{\_\_dump\_data(self)}: This method saves the data of the class to the \textbf{data.json} file.
    \item \textbf{\_\_load\_data(self)}: This method loads the data from the \textbf{data.json} file.
    \item \textbf{\_\_compound\_verbose\_and\_reaction\_to\_id(self, compound\_verbose, reaction\_id)}: Given a compound verbose and reaction ID, finds a compound ID.
    \item \textbf{\_\_fetch\_broken\_reactions(self)}: This method fetches the IDs of broken reactions.
    \item \textbf{\_\_query\_for\_reactions(self, reactions: list)}: This method queries the KEGG database (GET of REST) for the reactions (by groups of 10) and adds them to the \textbf{reactions} list.
    \item \textbf{\_\_fetch\_reaction\_substrates\_products\_ids(self)}: Creates the map \textbf{reaction\_id} to \textbf{substrate\_ids} and \textbf{product\_ids}. Uses the result from the KEGG API endpoint \href{https://rest.kegg.jp/list/reaction}{/list/reaction}, as well as \textbf{self.map\_reaction\_id\_to\_list\_compound\_id} and \textbf{self.map\_synonym\_to\_compound\_id}.
    \item \textbf{\_\_generate\_dat(self, pathway\_id: str)}: This private auxillary method generates the '.dat' file for the specified pathway ID.
\end{itemize}

\textbf{Public methods:}

\begin{itemize}
    \item \textbf{fetch\_map\_reaction\_id\_to\_list\_compound\_id()}: This method fetches the KEGG REST API endpoint \href{https://rest.kegg.jp/link/compound/reaction}{/link/compound/reaction} and returns a dictionary that maps reaction IDs to lists of compound IDs.
    \item \textbf{fetch\_map\_synonym\_to\_compound\_id()}: This method fetches the KEGG REST API endpoint \href{https://rest.kegg.jp/list/compound}{/list/compound} and returns a dictionary that maps compound synonyms to compound IDs.
    \item \textbf{fetch\_map\_pathway\_id\_to\_list\_reaction\_id()}: This method fetches the KEGG REST API endpoint \href{https://rest.kegg.jp/link/reaction/pathway}{/link/reaction/pathway} and returns a dictionary that maps pathway IDs to lists of reaction IDs. 
    \item \textbf{fetch\_map\_pathway\_id\_to\_description(organism=None)}: This method fetches the KEGG REST API endpoint \href{https://rest.kegg.jp/list/pathway}{/list/pathway} and returns a dictionary that maps pathway IDs to pathway descriptions. The optional \textbf{organism} parameter can be used to filter the pathways by organism.
    \item \textbf{generate\_dats(self, entries: list, overwrite: bool = False)}: This method generates the '.dat' files for the specified entries. The \textbf{entries} parameter is a list of pathway IDs, and the \textbf{overwrite} parameter determines whether to overwrite existing '.dat' files.
\end{itemize}


\subsubsection{GridUtil}

The \texttt{GridUtil} class provides utility methods for managing the grid layout in a Tkinter-based GUI. This class facilitates the dynamic adjustment of row and column configurations to enhance responsiveness during resizing. Here's an overview of its functionalities:

\textbf{Attributes:}

\begin{itemize}
\item \textbf{current\_row}: An integer representing the current row index.
\item \textbf{current\_column}: An integer representing the current column index.
\end{itemize}

\textbf{Constructor:}

\begin{itemize}
\item \texttt{\_\_init\_\_(self, row=0, column=0)}: Initializes the \texttt{GridUtil} object with optional parameters for the initial row and column indices. It also initializes lists for rows and columns that should not be resized.
\end{itemize}

\textbf{Methods:}

\begin{itemize}
\item \texttt{set\_row(self, row)}: Sets the current row index to the specified value.
\item \texttt{set\_column(self, column)}: Sets the current column index to the specified value.
\item \texttt{next\_row(self)}: Increments the current row index and resets the current column index to zero. Returns the updated row index.
\item \texttt{generate\_on\_resize(self)}: Returns a function that will be called on window resize. This function dynamically configures row and column weights based on the current state.
\item \texttt{do\_not\_resize\_col(self)}: Adds the current column index to the list of columns that will not be resized.
\item \texttt{do\_not\_resize\_row(self)}: Adds the current row index to the list of rows that will not be resized.
\item \texttt{place(self, rs=1, cs=1, sticky="we")}: Returns a dictionary with grid parameters for placing Tkinter widgets. Advances the current column index by \texttt{cs}.
\end{itemize}

This class is particularly useful for managing the grid layout and ensuring flexibility during GUI development.


\subsubsection{Pathway\_selector}

The \texttt{Pathway\_selector} class provides a graphical user interface for selecting and exploring biochemical pathways. It utilizes the KEGGIntegration class to fetch pathway data and display relevant information.

\textbf{Attributes:}

\begin{itemize}
    \item \textbf{default\_filter\_text}: A class attribute representing the default text in the filter box.
\end{itemize}

\textbf{Public methods:}

\begin{itemize}
    \item \textbf{\_\_init\_\_()}: Initializes the \texttt{Pathway\_selector} instance, setting up the graphical interface and necessary attributes.
    \item \textbf{filter\_enter\_action()}: Handles the filter box's $<enter>$ action to filter the search pool based on descriptions.
    \item \textbf{dropdown\_enter\_action()}: Handles the dropdown's enter action to select pathways based on descriptions.
    \item \textbf{dropdown\_id\_enter\_action()}: Handles the dropdown's enter action to select pathways based on IDs.
    \item \textbf{on\_entry\_filter\_click(event)}: Called when the filter entry is clicked to clear default text.
    \item \textbf{on\_entry\_filter\_leave(event)}: Called when the filter entry loses focus to add default text if needed.
    \item \textbf{set\_image()}: Sets the image in the image label to the selected pathway.
    \item \textbf{show\_image\_button\_click()}: Handles the click event for the "Show Image" button.
    \item \textbf{select\_pathway\_button\_click()}: Opens a new window with the selected pathway.
    \item \textbf{benchmark\_button\_click()}: Opens a new window for benchmarking.
    \item \textbf{update\_data\_button\_click()}: Updates the dataset, potentially causing an IP ban from the KEGG REST API.
    \item \textbf{on\_dropdown\_select(event)}: Called when an option is selected in the dropdown for descriptions.
    \item \textbf{on\_dropdown\_id\_select(event)}: Called when an option is selected in the dropdown for IDs.
    \item \textbf{clear\_description\_label(event)}: Clears the description label.
    \item \textbf{set\_description\_label\_func(text)}: Returns a function that sets the description label to the given text.
    \item \textbf{dropdown\_set\_values()}: Sets the values of the dropdown.
\end{itemize}

The \texttt{Pathway\_selector} class provides a comprehensive interface for exploring biochemical pathways, allowing users to filter, search, and select pathways based on descriptions or IDs. Additionally, it includes features for showing pathway images, opening pathway windows, and initiating benchmarking processes. The class is integrated with the KEGGIntegration class for seamless data retrieval and updates.

\subsubsection{Benchmark\_view}

The \texttt{Benchmark\_view} class provides a graphical user interface for running benchmarks using various solvers and models. It interacts with the KEGGIntegration class to fetch data and generate '.dat' files for benchmarking.

\textbf{Attributes:}

\begin{itemize}
    \item \textbf{solvers}: A dictionary mapping solver names to their corresponding identifiers.
    \item \textbf{models}: A dictionary mapping model names to their file paths.
    \item \textbf{dats}: A dictionary to store '.dat' files for benchmark entries.
    \item \textbf{result\_count}: An integer representing the count of benchmark results.
    \item \textbf{current\_test\_id}: A string representing the current test identifier.
    \item \textbf{file}: A file object for writing benchmark results.
\end{itemize}

\textbf{Public methods:}

\begin{itemize}
    \item \textbf{\_\_init\_\_(self, master)}: Initializes the Benchmark\_view instance, setting up the graphical interface and necessary attributes.
    \item \textbf{start\_button\_click()}: Starts the benchmark in a separate thread, creating a new entry in the Treeview and initiating the benchmarking process.
    \item \textbf{run\_benchmark()}: Runs the benchmark process, handling the entire workflow from data preparation to solving entries.
    \item \textbf{prepare\_dats()}: Prepares the '.dat' files for benchmark entries.
    \item \textbf{solve\_all\_entries()}: Solves all benchmark entries using the selected solver and models, updating the graphical interface and writing results to a file.
    \item \textbf{set\_benchmark\_average(entry, solver\_id, valid\_duration\_lists)}: Sets the benchmark average for a specific entry and solver.
    \item \textbf{get\_last\_entry\_treeview\_id()}: Retrieves the last entry ID from the Treeview.
    \item \textbf{insert\_to\_treeview(parent, text, *values)}: Inserts a new entry into the Treeview component of the graphical interface.
    \item \textbf{create\_tickboxes(parent)}: Creates tickboxes in the graphical interface for specific options.
\end{itemize}
